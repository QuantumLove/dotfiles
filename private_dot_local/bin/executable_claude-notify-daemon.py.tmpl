#!/usr/bin/env python3
"""
Claude Code Notification Daemon for DevContainers

Runs on macOS host, listens on localhost:9876
Receives HTTP POST requests from Claude Code running inside containers
Triggers native macOS notifications with terminal-notifier

Clicking a notification opens the corresponding VS Code DevContainer window.

Usage:
  ./claude-notify-daemon.py

API:
  POST http://localhost:9876
  Body: {
    "title": "Claude Code",
    "message": "Task completed",
    "container": "container-name",
    "containerId": "abc123...",  // full or short container ID
    "workDir": "/workspaces/project"
  }
"""

from http.server import HTTPServer, BaseHTTPRequestHandler
import json
import subprocess
import sys
from datetime import datetime
from urllib.parse import quote

PORT = 9876

class NotificationHandler(BaseHTTPRequestHandler):
    def do_POST(self):
        # Read request body
        content_length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(content_length).decode('utf-8')

        try:
            # Parse JSON
            data = json.loads(body)
            title = data.get('title', 'Claude Code')
            message = data.get('message', 'Notification')
            container = data.get('container', 'unknown')
            container_id = data.get('containerId', '')
            work_dir = data.get('workDir', '')

            # Trigger notification with click action
            success = self._send_notification(title, message, container_id, work_dir)

            # Log
            timestamp = datetime.now().strftime('%H:%M:%S')
            status = '‚úÖ' if success else '‚ùå'
            click_info = f" (click: {work_dir})" if work_dir else ""
            print(f"{status} [{timestamp}] [{container}] {title}: {message}{click_info}")

            # Send response
            self.send_response(200 if success else 500)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            response = json.dumps({'status': 'ok' if success else 'error'})
            self.wfile.write(response.encode('utf-8'))

        except json.JSONDecodeError as e:
            print(f"‚ùå Invalid JSON: {e}")
            self.send_response(400)
            self.end_headers()
        except Exception as e:
            print(f"‚ùå Error: {e}")
            self.send_response(500)
            self.end_headers()

    def _get_full_container_id(self, short_id):
        """Resolve short container ID to full ID using docker inspect"""
        if not short_id:
            return None
        try:
            result = subprocess.run(
                ['docker', 'inspect', '--format', '{{ "{{" }}.Id{{ "}}" }}', short_id],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0:
                return result.stdout.strip()
        except Exception:
            pass
        return None

    def _build_vscode_uri(self, container_id, work_dir):
        """
        Build VS Code Remote URI for attached container.

        Format: vscode://vscode-remote/attached-container+<hex-encoded-config>/<path>
        where config is JSON like {"containerName":"/container-name"}
        """
        if not container_id:
            return None

        # Get full container ID
        full_id = container_id
        if len(container_id) < 64:
            resolved = self._get_full_container_id(container_id)
            if resolved:
                full_id = resolved

        # Get container name for the URI
        try:
            result = subprocess.run(
                ['docker', 'inspect', '--format', '{{ "{{" }}.Name{{ "}}" }}', full_id],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0:
                container_name = result.stdout.strip()  # includes leading /
                # Build the config JSON and hex-encode it
                config = f'{{ "{{" }}"containerName":"{container_name}"{{ "}}" }}'
                hex_config = config.encode().hex()
                path = work_dir if work_dir else '/workspaces'
                return f"vscode://vscode-remote/attached-container+{hex_config}{path}"
        except Exception:
            pass

        return None

    def _send_notification(self, title, message, container_id='', work_dir=''):
        """Send macOS notification using terminal-notifier or osascript"""
        try:
            # Build click action
            click_args = []

            # Try VS Code URI for containers
            vscode_uri = self._build_vscode_uri(container_id, work_dir)
            if vscode_uri:
                click_args = ['-open', vscode_uri]
            else:
                # Fallback: just activate VS Code
                click_args = ['-activate', 'com.microsoft.VSCode']

            # Try terminal-notifier first
            cmd = [
                'terminal-notifier',
                '-title', title,
                '-message', message,
                '-sound', 'default',
            ] + click_args

            result = subprocess.run(cmd, capture_output=True, timeout=5)
            return result.returncode == 0
        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
            try:
                # Fallback to osascript (no click action support)
                subprocess.run([
                    'osascript', '-e',
                    f'display notification "{message}" with title "{title}" sound name "Ping"'
                ], timeout=2, check=True)
                return True
            except Exception:
                return False

    def log_message(self, format, *args):
        # Suppress default HTTP logging (we do custom logging)
        pass

def run_daemon():
    """Start the notification daemon"""
    server = HTTPServer(('localhost', PORT), NotificationHandler)
    print("üîî Claude Notification Daemon")
    print(f"   Listening on localhost:{PORT}")
    print(f"   Containers: POST to http://host.docker.internal:{PORT}")
    print("   Format: {'title': '...', 'message': '...', 'container': '...', 'containerId': '...', 'workDir': '...'}")
    print(f"   Click action: Opens VS Code DevContainer window")
    print(f"   Press Ctrl+C to stop\n")

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nüëã Shutting down daemon")
        server.shutdown()
        sys.exit(0)

if __name__ == '__main__':
    run_daemon()
