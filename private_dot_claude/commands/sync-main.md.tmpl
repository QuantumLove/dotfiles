---
name: sync-main
description: Safely sync main branch and rebase current branch with conflict detection
permissions:
  - Bash(git fetch *)
  - Bash(git pull *)
  - Bash(git rebase *)
  - Bash(git stash *)
---

# Sync Main - Safe Branch Synchronization

Safely update main branch and rebase your current branch, with automatic conflict detection and rollback.

## Philosophy
Keep branches up-to-date without losing work. Detect conflicts early, provide escape hatches.

## Usage

```bash
/sync-main                    # Sync and rebase current branch
/sync-main --main-only        # Only update main, don't rebase
/sync-main --dry-run          # Preview what would happen
```

## What It Does

1. **Stash uncommitted changes** (if any)
2. **Fetch latest from remote**
3. **Update main branch**
4. **Rebase current branch onto main**
5. **Detect conflicts** and provide resolution steps
6. **Restore stashed changes**

## Implementation

```bash
#!/bin/bash
set -e

echo "ğŸ”„ Sync Main - Safe Branch Synchronization"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

DRY_RUN=false
MAIN_ONLY=false

# Parse arguments
for arg in "$@"; do
  case $arg in
    --dry-run)
      DRY_RUN=true
      ;;
    --main-only)
      MAIN_ONLY=true
      ;;
  esac
done

# Save current branch
CURRENT_BRANCH=$(git branch --show-current)

if [ -z "$CURRENT_BRANCH" ]; then
  echo "âŒ Not on a branch (detached HEAD). Checkout a branch first."
  exit 1
fi

if [ "$CURRENT_BRANCH" = "main" ] || [ "$CURRENT_BRANCH" = "master" ]; then
  echo "â„¹ï¸  Already on main branch. Will pull latest changes."
  MAIN_ONLY=true
fi

# Check for uncommitted changes
if ! git diff-index --quiet HEAD --; then
  echo "âš ï¸  Uncommitted changes detected"
  if [ "$DRY_RUN" = true ]; then
    echo "   Would stash changes before syncing"
  else
    echo "   Stashing changes..."
    git stash push -m "sync-main auto-stash $(date +%Y-%m-%d-%H%M%S)"
    STASHED=true
  fi
  echo ""
fi

# Fetch latest
echo "ğŸ“¡ Fetching latest from origin..."
if [ "$DRY_RUN" = false ]; then
  git fetch origin
fi
echo ""

# Update main branch
echo "ğŸ“¥ Updating main branch..."
if [ "$DRY_RUN" = true ]; then
  echo "   Would checkout main and pull latest"
else
  git checkout main
  git pull origin main
fi
echo ""

# Rebase current branch (if not main-only mode)
if [ "$MAIN_ONLY" = false ] && [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "master" ]; then
  echo "ğŸ”€ Rebasing $CURRENT_BRANCH onto main..."

  if [ "$DRY_RUN" = true ]; then
    echo "   Would checkout $CURRENT_BRANCH and rebase onto main"

    # Show what commits would be replayed
    COMMITS_TO_REPLAY=$(git log main..$CURRENT_BRANCH --oneline | wc -l | tr -d ' ')
    echo "   Commits to replay: $COMMITS_TO_REPLAY"

    if [ "$COMMITS_TO_REPLAY" -gt 0 ]; then
      echo ""
      echo "   Commits that would be rebased:"
      git log main..$CURRENT_BRANCH --oneline --no-decorate
    fi
  else
    git checkout "$CURRENT_BRANCH"

    # Attempt rebase with conflict detection
    if git rebase main; then
      echo "âœ… Rebase successful!"
    else
      echo "âŒ Rebase conflicts detected!"
      echo ""
      echo "Conflicts in:"
      git diff --name-only --diff-filter=U
      echo ""
      echo "Options:"
      echo "  1. Resolve conflicts manually:"
      echo "     - Edit conflicted files"
      echo "     - git add <file>"
      echo "     - git rebase --continue"
      echo ""
      echo "  2. Abort rebase:"
      echo "     git rebase --abort"
      echo ""
      echo "  3. Use merge instead:"
      echo "     git rebase --abort"
      echo "     git merge main"

      # Don't restore stash if rebase failed
      exit 1
    fi
  fi
  echo ""
fi

# Restore stashed changes
if [ "$STASHED" = true ] && [ "$DRY_RUN" = false ]; then
  echo "ğŸ“¦ Restoring stashed changes..."
  if git stash pop; then
    echo "âœ… Stashed changes restored"
  else
    echo "âŒ Conflict restoring stash!"
    echo "   Stash preserved. Resolve conflicts, then:"
    echo "   git stash pop"
    exit 1
  fi
  echo ""
fi

# Summary
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âœ… Sync complete!"
echo ""

if [ "$MAIN_ONLY" = false ] && [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "master" ]; then
  echo "   Branch: $CURRENT_BRANCH"
  echo "   Status: Rebased onto latest main"
  echo ""
  echo "   Your branch is now up-to-date with main."
  echo "   Continue working or push changes:"
  echo "     git push --force-with-lease"
else
  echo "   Branch: main"
  echo "   Status: Up-to-date with origin/main"
fi
```

## Safety Features

1. **Auto-stash** - Preserves uncommitted work
2. **Conflict detection** - Stops if conflicts occur
3. **Dry-run mode** - Preview before executing
4. **Rollback support** - Clear instructions to abort
5. **Force-with-lease suggestion** - Safe force push

## When To Use

**Regular sync (recommended daily):**
```bash
/sync-main
```

**Just update main, keep working on feature:**
```bash
/sync-main --main-only
```

**Preview changes before syncing:**
```bash
/sync-main --dry-run
```

## Conflict Resolution

If rebase conflicts occur:

1. **View conflicted files:**
   ```bash
   git diff --name-only --diff-filter=U
   ```

2. **Edit and resolve conflicts**, then:
   ```bash
   git add <resolved-file>
   git rebase --continue
   ```

3. **Or abort and merge instead:**
   ```bash
   git rebase --abort
   git merge main
   ```

## Related Commands

- `/start-work` - Creates new worktree (auto-synced)
- `/review` - Review changes after sync
- `/safe-ship` - Pre-push validation
